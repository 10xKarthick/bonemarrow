// Generated by dts-bundle-generator v9.5.1

/**
 * Injectable logger interface — keeps BoneMarrow logging-agnostic.
 * Pass a custom logger via the constructor to integrate with your
 * existing logging infrastructure (e.g. Sentry, Datadog, custom).
 *
 * Defaults to console in debug mode.
 */
export interface EmitterLogger {
	log(message: string): void;
	warn(message: string): void;
	error(message: string, error: unknown): void;
}
export interface FetchOptions<T> {
	/**
	 * BoneMarrow Scope. When provided:
	 * - The request is automatically aborted when the scope is disposed.
	 * - Deduplication (if enabled) is isolated per Scope instance.
	 */
	scope?: Scope;
	/** Request timeout in milliseconds. Applies per attempt, not total. */
	timeout?: number;
	/**
	 * Number of retry attempts after the first failure. Default: 0.
	 * retryOnFailure: 1 → up to 2 total attempts (1 initial + 1 retry).
	 * retryOnFailure: N → up to N+1 total attempts.
	 * Aborts are never retried — they are always terminal.
	 */
	retryOnFailure?: number;
	/**
	 * Milliseconds to wait between retry attempts. Default: 0.
	 * Respects scope disposal — if the scope is disposed during a delay,
	 * the wait is cut short and the attempt is abandoned immediately.
	 */
	retryDelay?: number;
	/**
	 * Deduplicate concurrent requests with the same method + URL (+ body for
	 * non-GET requests) per Scope instance.
	 * Requires scope to be provided — silently ignored without one.
	 * Default: false.
	 */
	dedupe?: boolean;
	/**
	 * Passed directly to fetch(). Do not include signal — it is managed
	 * internally and will be overwritten if provided.
	 */
	init?: Omit<RequestInit, "signal">;
	/** Transform the parsed JSON before returning. Runs after res.json(). */
	parse?: (json: unknown) => T;
}
export interface RefreshOptions {
	/**
	 * Milliseconds between the end of one execution and the start of the next.
	 * Must be greater than 0.
	 */
	interval: number;
	/** Scope that owns this refresh loop. Loop stops when scope is disposed. */
	scope: Scope;
	/** Run immediately on creation. Default: true. */
	immediate?: boolean;
	/** Start in a paused state. Default: false. */
	startPaused?: boolean;
	/** Called when fn throws or rejects. If omitted, errors are logged to console. */
	onError?: (error: unknown) => void;
	/**
	 * Stop after this many consecutive errors. 0 = retry forever. Default: 0.
	 * Count resets to zero on any successful execution.
	 */
	maxRetries?: number;
	/**
	 * Exponential backoff on consecutive errors, capped at 10× interval.
	 * Default: false.
	 */
	backoff?: boolean;
	/**
	 * Optional debug callback. Called with diagnostic messages.
	 * Keep out of production — wire to your logger or console as needed.
	 *
	 * @example
	 * onDebug: (msg) => console.log(msg)
	 */
	onDebug?: (message: string) => void;
}
export interface RefreshController {
	/** Suspend scheduling. Any in-flight execution completes naturally. */
	pause(): void;
	/**
	 * Resume scheduling after a pause. Starts a new tick immediately.
	 * No-op if not paused or already stopped.
	 */
	resume(): void;
	/** Permanently stop the loop and abort any in-flight execution. */
	stop(): void;
	/** True if the loop is currently paused. */
	isPaused(): boolean;
	/**
	 * True if fn() is currently executing.
	 * Remains true during a tick that started before pause() was called.
	 */
	isExecuting(): boolean;
}
export type DisposeFn = () => void;
export interface Scope {
	/**
	 * AbortSignal that is aborted when this scope is disposed.
	 * Wire this to fetch(), refresh loops, or any cancellable async work.
	 */
	readonly signal: AbortSignal;
	/**
	 * Register a cleanup function to run when this scope is disposed.
	 *
	 * If the scope is already disposed, fn() is called immediately.
	 * This is intentional — registration on a dead scope is never silently dropped.
	 *
	 * Cleanups run in LIFO order (last registered, first called).
	 */
	onDispose(fn: DisposeFn): void;
	/**
	 * Create a child scope. The child is disposed automatically when the
	 * parent is disposed. The child can also be disposed independently —
	 * doing so removes it from the parent's tracking without affecting the parent.
	 *
	 * If called on an already-disposed scope, returns a pre-disposed scope
	 * and logs a warning.
	 */
	createChild(): Scope;
	/**
	 * Dispose this scope and all of its children.
	 * Idempotent — safe to call multiple times.
	 *
	 * Disposal order:
	 * 1. Children disposed (recursively, depth-first)
	 * 2. AbortSignal aborted
	 * 3. Cleanups run (LIFO)
	 */
	dispose(): void;
}
export interface AutoRefreshOptions {
	interval: number;
	/**
	 * Child scope to own the refresh loop.
	 * If omitted, the collection's own scope is used — the loop runs until
	 * the collection is destroyed.
	 *
	 * ⚠️ If you pass a custom scope, the collection's destruction will NOT
	 * stop the loop unless that scope is a child of the collection's scope.
	 * Prefer: `collection.autoRefresh(url, { scope: collScope.createChild() })`
	 * or omit scope and let the collection own the loop.
	 */
	scope?: Scope;
	immediate?: boolean;
	startPaused?: boolean;
	onError?: (error: unknown) => void;
	maxRetries?: number;
	backoff?: boolean;
	onDebug?: (message: string) => void;
}
export interface ViewOptions {
	/**
	 * Automatically destroy the view when its root element is removed from
	 * the DOM. Uses MutationObserver.
	 *
	 * ⚠️ Requires the root element to be attached to the DOM at construction
	 * time. If root has no parentElement, the observer cannot attach and
	 * autoDestroy will silently not work.
	 *
	 * ⚠️ If the root element is removed and re-inserted before the
	 * MutationObserver fires, the view will be destroyed on the first removal
	 * even if re-inserted. For dynamic node movement, manage lifecycle manually.
	 *
	 * Default: true.
	 */
	autoDestroy?: boolean;
	/**
	 * Parent scope. If provided, the view's scope is created as a child —
	 * disposing the parent automatically disposes this view.
	 */
	parentScope?: Scope;
}
/**
 * Create a new scope attached to the window scope.
 * Automatically disposed when the page is hidden or unloaded.
 *
 * For testing or non-browser environments, use createRootScope() instead.
 */
export declare function createScope(options?: {
	debug?: boolean;
}): Scope;
/**
 * Create a standalone root scope with no parent.
 *
 * Use this in:
 * - Tests — gives you full control over scope lifetime without window dependency
 * - Non-browser environments (Node, workers) — no window to attach to
 * - Cases where you need an isolated scope tree
 *
 * You are responsible for calling dispose() on root scopes.
 *
 * @example
 * const scope = createRootScope();
 * // ... do work ...
 * scope.dispose();
 */
export declare function createRootScope(options?: {
	debug?: boolean;
}): Scope;
/**
 * Check if a scope has been disposed.
 *
 * Equivalent to scope.signal.aborted — provided as a readable alternative.
 */
export declare function isScopeDisposed(scope: Scope): boolean;
/**
 * Type-safe event emitter with automatic cleanup and error isolation.
 *
 * @version 1.2.0
 *
 * Designed for BoneMarrow lifecycle events. Stays predictable:
 * - Sync emit isolates handler errors
 * - Async emit surfaces all rejections via AggregateError (ES2021+)
 * - Scope integration handles automatic cleanup
 * - Debug mode includes leak detection
 *
 * @example
 * type Events = {
 *   change: [data: string];
 *   reset:  [];
 * };
 *
 * const emitter = new TypedEmitter<Events>();
 * emitter.on("change", (data) => console.log(data));
 */
export declare class TypedEmitter<TEvents extends Record<string, unknown[]>> {
	private events;
	private debugMode;
	private logger;
	private readonly maxListeners;
	/**
	 * @param options.debug        - Enable debug/leak logging. Dev only — disable in production.
	 * @param options.logger       - Custom logger. Defaults to console.
	 * @param options.maxListeners - Warn threshold per event (dev only). Default: 50.
	 */
	constructor(options?: {
		debug?: boolean;
		logger?: EmitterLogger;
		maxListeners?: number;
	});
	/**
	 * Register an event listener.
	 *
	 * Returns a DisposeFn that removes the listener when called.
	 * Pass a Scope to auto-remove when the scope is disposed.
	 */
	on<K extends keyof TEvents>(event: K, fn: (...args: TEvents[K]) => void, scope?: Scope): DisposeFn;
	/**
	 * Register a one-time event listener.
	 *
	 * The listener is removed *before* the handler executes.
	 * If the handler throws, the listener is already gone — intentional.
	 * There is no retry semantics. Use `on()` if you need to control removal yourself.
	 */
	once<K extends keyof TEvents>(event: K, fn: (...args: TEvents[K]) => void, scope?: Scope): DisposeFn;
	/**
	 * Returns a Promise that resolves with the args of the next emission.
	 *
	 * ⚠️ Scope disposal caveat: if the provided scope is disposed before the
	 * event fires, the Promise will never resolve or reject — it hangs silently.
	 * If your scope may be short-lived, either:
	 *   - Don't pass a scope, and manage cleanup manually
	 *   - Or set a timeout externally: `Promise.race([emitter.onceAsync(...), timeout])`
	 *
	 * @example
	 * const [data] = await emitter.onceAsync("ready");
	 */
	onceAsync<K extends keyof TEvents>(event: K, scope?: Scope): Promise<TEvents[K]>;
	/**
	 * Emit an event synchronously to all registered listeners.
	 *
	 * Errors are isolated per handler — one failure does not stop others.
	 * If you need to know when handlers have finished async work, use emitAsync().
	 */
	emit<K extends keyof TEvents>(event: K, ...args: TEvents[K]): void;
	/**
	 * Emit an event and await all async handlers.
	 *
	 * All handlers always run regardless of individual failures.
	 * Any rejections are collected and re-thrown together as an AggregateError.
	 *
	 * Use this for lifecycle hooks where async work must complete before
	 * continuing (e.g. save hooks, pre-unmount cleanup).
	 *
	 * ⚠️ Requires ES2021+ (AggregateError). Check your tsconfig target.
	 *    If targeting older environments, add a polyfill.
	 *
	 * @example
	 * await emitter.emitAsync("beforeSave", payload);
	 */
	emitAsync<K extends keyof TEvents>(event: K, ...args: TEvents[K]): Promise<void>;
	/**
	 * Remove all listeners for a specific event.
	 *
	 * ⚠️ Scope asymmetry: if listeners were registered with a Scope, the Scope
	 * still holds its disposer reference after off() is called. The event is
	 * gone, but the disposer will run harmlessly when the scope is disposed.
	 * This is intentional — the contract is safe, just asymmetrical.
	 */
	off<K extends keyof TEvents>(event: K): void;
	/**
	 * Remove all listeners for all events.
	 */
	clear(): void;
	hasListeners<K extends keyof TEvents>(event: K): boolean;
	listenerCount<K extends keyof TEvents>(event: K): number;
	eventNames(): Array<keyof TEvents>;
	setDebug(enabled: boolean): void;
}
/**
 * Untyped emitter alias for quick prototyping or dynamic event names.
 *
 * Backed by TypedEmitter — zero duplication, zero runtime overhead.
 * Prefer TypedEmitter with explicit event types in production code.
 *
 * @example
 * const emitter = new Emitter();
 * emitter.on("change", (data) => console.log(data));
 */
export type Emitter = TypedEmitter<Record<string, unknown[]>>;
export declare const Emitter: new (options?: ConstructorParameters<typeof TypedEmitter>[0]) => TypedEmitter<Record<string, unknown[]>>;
/**
 * Fetch and parse a JSON response with scope-aware cancellation.
 *
 * If a scope is provided, the request is automatically aborted when the scope
 * is disposed — no configuration required.
 *
 * @example
 * const users = await fetchJson<User[]>("/api/users", { scope, timeout: 5000 });
 *
 * @example
 * // With retry, backoff delay, and deduplication:
 * const report = await fetchJson<Report>("/api/report", {
 *   scope,
 *   retryOnFailure: 3,
 *   retryDelay: 500,
 *   dedupe: true,
 * });
 */
export declare function fetchJson<T>(url: string, options?: FetchOptions<T>): Promise<T>;
export declare class Model<T extends object> {
	private data;
	private initial;
	private emitter;
	private scope;
	/**
	 * Create a model with an initial state.
	 *
	 * @param initial - Initial state. Shallow-cloned on construction and reset.
	 * @param scope   - Scope that owns this model. When the scope is disposed,
	 *                  the model is destroyed automatically. If omitted, a root
	 *                  scope is created — you are responsible for calling
	 *                  model.destroy() to clean up.
	 *
	 * ⚠️ Scope ownership: passing an external scope grants lifecycle ownership
	 * to this model. Calling destroy() will dispose that scope, which affects
	 * all other resources tied to it. If multiple models share a scope,
	 * destroying any one of them destroys all of them.
	 * Use a dedicated child scope per model if you need independent lifetimes:
	 *   `new Model(data, parentScope.createChild())`
	 *
	 * @example
	 * const model = new Model({ count: 0 }, scope);
	 */
	constructor(initial: T, scope?: Scope);
	get<K extends keyof T>(key: K): T[K];
	getAll(): Readonly<T>;
	/**
	 * True if the current state differs from the initial state.
	 * Shallow comparison.
	 */
	isDirty(): boolean;
	has<K extends keyof T>(key: K, value: T[K]): boolean;
	/**
	 * Apply a partial patch to the model state.
	 * Only changed keys are applied. Emits "change" only if something changed.
	 * Returns true if any key changed, false if state was already identical.
	 */
	set(patch: Partial<T>): boolean;
	/**
	 * Reset model state to the initial values provided at construction.
	 * Emits "change" only if state differs from initial.
	 */
	reset(): void;
	/**
	 * Listen for any state change.
	 * fn receives the patch — only the keys that actually changed.
	 *
	 * @example
	 * model.onChange((patch) => console.log(patch), scope);
	 */
	onChange(fn: (patch: Partial<T>) => void, scope?: Scope): DisposeFn;
	/**
	 * Watch a single key for changes.
	 * fn is called only when that specific key changes.
	 *
	 * @example
	 * model.watch("username", (value) => console.log(value), scope);
	 */
	watch<K extends keyof T>(key: K, fn: (value: T[K]) => void, scope?: Scope): DisposeFn;
	/**
	 * Fetch a partial state patch from a URL and apply it to the model.
	 * Uses the model's own scope — aborted if the model is destroyed.
	 * Returns the full model state after patching.
	 */
	fetch(url: string, timeout?: number): Promise<Readonly<T>>;
	/**
	 * Start a sequential auto-refresh loop that keeps the model up to date.
	 *
	 * Returns a RefreshController — use pause(), resume(), stop() to control
	 * the loop without destroying the model.
	 *
	 * If no scope is provided in options, the model's own scope owns the loop —
	 * it stops automatically when the model is destroyed.
	 *
	 * @example
	 * const refresh = model.autoRefresh("/api/user", { interval: 5000 });
	 * refresh.pause(); // while editing
	 * refresh.resume();
	 */
	autoRefresh(url: string, options: AutoRefreshOptions): RefreshController;
	/**
	 * Destroy the model explicitly.
	 * Disposes the model's scope — this stops all refresh loops, aborts
	 * in-flight fetches, and clears all listeners.
	 *
	 * ⚠️ If a scope was passed at construction, this disposes that scope too.
	 * Any other resources tied to that scope will also be destroyed.
	 * Idempotent — safe to call multiple times.
	 *
	 * After destruction, all method calls throw.
	 */
	destroy(): void;
	isDestroyed(): boolean;
	private _destroy;
	private checkDestroyed;
}
export declare class Collection<T> {
	private items;
	private emitter;
	private scope;
	/**
	 * Create a collection, optionally seeded with initial items.
	 *
	 * @param initial - Initial items. Shallow-cloned on construction.
	 * @param scope   - Scope that owns this collection. When the scope is
	 *                  disposed, the collection is destroyed automatically.
	 *                  If omitted, a root scope is created — you are
	 *                  responsible for calling destroy() to clean up.
	 *
	 * ⚠️ Scope ownership: passing an external scope grants lifecycle ownership
	 * to this collection. Calling destroy() disposes that scope, which affects
	 * all other resources tied to it. Use a dedicated child scope per
	 * collection if you need independent lifetimes:
	 *   `new Collection(items, parentScope.createChild())`
	 */
	constructor(initial?: T[], scope?: Scope);
	getAll(): T[];
	get length(): number;
	at(index: number): T | undefined;
	find(predicate: (item: T, index: number) => boolean): T | undefined;
	findIndex(predicate: (item: T, index: number) => boolean): number;
	filter(predicate: (item: T, index: number) => boolean): T[];
	map<U>(fn: (item: T, index: number) => U): U[];
	forEach(fn: (item: T, index: number) => void): void;
	some(predicate: (item: T, index: number) => boolean): boolean;
	every(predicate: (item: T, index: number) => boolean): boolean;
	add(...items: T[]): void;
	/**
	 * Remove all items matching the predicate.
	 * Iterates backwards to avoid index-shift bugs during splice.
	 * Returns the removed items in their original order.
	 * Emits "remove" only if at least one item was removed.
	 */
	remove(predicate: (item: T, index: number) => boolean): T[];
	removeAt(index: number): T | undefined;
	/**
	 * Apply a shallow patch to all items matching the predicate.
	 * Only items that actually change are included in the "update" emission.
	 *
	 * Patch is applied shallowly — consistent with Model.set() semantics.
	 * Returns the items that were updated.
	 *
	 * @example
	 * collection.update(
	 *   (user) => user.id === 42,
	 *   { name: "Alice" }
	 * );
	 */
	update(predicate: (item: T, index: number) => boolean, patch: Partial<T>): T[];
	/**
	 * Move an item from one index to another.
	 * Emits "sort" to signal an ordering change.
	 * No-op if either index is out of bounds or indices are equal.
	 */
	move(fromIndex: number, toIndex: number): void;
	sort(compareFn?: (a: T, b: T) => number): void;
	/**
	 * Replace all items. Emits "reset" with the new item list.
	 */
	reset(items: T[]): void;
	/**
	 * Remove all items. No-op if already empty.
	 * Emits "reset" with an empty array.
	 */
	clear(): void;
	/**
	 * Fetch an item array from a URL and replace the collection contents.
	 * Uses the collection's own scope — aborted if the collection is destroyed.
	 * Returns the full collection after reset.
	 */
	fetch(url: string, timeout?: number): Promise<T[]>;
	/**
	 * Start a sequential auto-refresh loop that keeps the collection up to date.
	 *
	 * Returns a RefreshController — use pause(), resume(), stop() to control
	 * the loop without destroying the collection.
	 *
	 * If no scope is provided in options, the collection's own scope owns the
	 * loop — it stops automatically when the collection is destroyed.
	 *
	 * ⚠️ Custom scope ownership: see AutoRefreshOptions.scope for details.
	 */
	autoRefresh(url: string, options: AutoRefreshOptions): RefreshController;
	onAdd(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onRemove(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onUpdate(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onReset(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onSort(fn: () => void, scope?: Scope): DisposeFn;
	/**
	 * Listen for any data change — add, remove, update, or reset.
	 * Sort is intentionally excluded: sort changes ordering, not data.
	 * Use onSort() separately if you need to react to ordering changes.
	 *
	 * Returns a single DisposeFn that removes all four listeners at once.
	 */
	onChange(fn: () => void, scope?: Scope): DisposeFn;
	/**
	 * Destroy the collection explicitly.
	 * Disposes the collection's scope — stops all refresh loops, aborts
	 * in-flight fetches, and clears all listeners.
	 *
	 * ⚠️ If a scope was passed at construction, this disposes that scope too.
	 * Idempotent — safe to call multiple times.
	 */
	destroy(): void;
	isDestroyed(): boolean;
	private _destroy;
	private checkDestroyed;
}
export declare class Elements {
	private readonly _nodes;
	constructor(nodes: Element[]);
	get length(): number;
	/**
	 * Returns a shallow copy of the underlying Element array.
	 * Mutations to the returned array do not affect this wrapper.
	 */
	toArray(): Element[];
	each(fn: (el: Element, index: number) => void): this;
	get(index?: number): Element | null;
	first(): Element | null;
	last(): Element | null;
	find(selector: string): Elements;
	filter(predicate: ((el: Element, index: number) => boolean) | string): Elements;
	/**
	 * Return elements that do NOT match the selector.
	 * Inverse of filter(selector).
	 */
	not(selector: string): Elements;
	parent(): Elements;
	/**
	 * Return all sibling elements (excluding the elements themselves).
	 */
	siblings(): Elements;
	closest(selector: string): Elements;
	children(): Elements;
	/**
	 * Get the text content of the first element,
	 * or set text content on all elements.
	 */
	text(): string;
	text(value: string): this;
	/**
	 * Get the innerHTML of the first element,
	 * or set innerHTML on all elements.
	 *
	 * ⚠️ Setting innerHTML with untrusted content is an XSS risk.
	 * Sanitize before calling if content comes from user input.
	 */
	html(): string;
	html(value: string): this;
	/**
	 * Get an attribute value from the first element (null if absent),
	 * or set an attribute on all elements.
	 *
	 * Returns null (not "") when the attribute is absent — to distinguish
	 * absence from an empty attribute value.
	 */
	attr(name: string): string | null;
	attr(name: string, value: string): this;
	removeAttr(name: string): this;
	/**
	 * Get a data attribute value from the first element (null if absent),
	 * or set a data attribute on all elements.
	 *
	 * Returns null (not "") when the key is absent.
	 */
	data(key: string): string | null;
	data(key: string, value: string): this;
	/**
	 * Get the value of the first form element,
	 * or set the value on all form elements.
	 * Non-form elements are silently skipped.
	 */
	val(): string;
	val(value: string): this;
	/**
	 * Add an event listener to all elements.
	 *
	 * If a Scope is provided, listeners are removed automatically when the
	 * scope is disposed.
	 *
	 * ⚠️ Each element in the collection registers its own onDispose cleanup.
	 * On a large collection (e.g. 100 elements), this produces 100 onDispose
	 * registrations on the scope. This is correct behavior — each element
	 * needs its own cleanup — not a leak. Debug mode may warn about cleanup
	 * accumulation; this is a known false positive for large element sets.
	 */
	on(event: string, handler: EventListener, scope?: Scope): this;
	/**
	 * Add a one-time event listener to all elements.
	 * The listener removes itself after firing once per element.
	 */
	once(event: string, handler: EventListener): this;
	off(event: string, handler: EventListener): this;
	/**
	 * Dispatch a CustomEvent on all elements.
	 *
	 * Defaults to bubbling and cancelable — consistent with native DOM events.
	 * Pass `bubbles: false` if you explicitly need a non-bubbling event.
	 */
	trigger(event: string, detail?: unknown, options?: {
		bubbles?: boolean;
		cancelable?: boolean;
	}): this;
	addClass(classes: string): this;
	removeClass(classes: string): this;
	toggleClass(classes: string, force?: boolean): this;
	hasClass(className: string): boolean;
	/**
	 * Get a computed style value from the first element,
	 * set a CSS property on all elements,
	 * or set multiple CSS properties via an object.
	 */
	css(property: string): string;
	css(property: string, value: string): this;
	css(properties: Record<string, string>): this;
	show(): this;
	hide(): this;
	toggle(show?: boolean): this;
	/**
	 * True if any element in the collection is visible.
	 *
	 * ⚠️ Uses offsetParent for visibility detection, which returns null for
	 * `position: fixed` elements even when they are visible. For fixed
	 * elements, check visibility manually via getBoundingClientRect() or
	 * getComputedStyle().
	 */
	isVisible(): boolean;
	/**
	 * Append content to each element.
	 *
	 * - string → inserted as HTML via insertAdjacentHTML
	 * - Elements → each child is cloned and appended
	 * - Element → cloned when this wrapper has multiple targets,
	 *             moved (not cloned) when there is exactly one target
	 */
	append(content: Elements | Element | string): this;
	/**
	 * Prepend content to each element.
	 *
	 * - string → inserted as HTML via insertAdjacentHTML
	 * - Elements → each child is cloned and prepended
	 * - Element → cloned when this wrapper has multiple targets,
	 *             moved (not cloned) when there is exactly one target
	 */
	prepend(content: Elements | Element | string): this;
	remove(): this;
	empty(): this;
	clone(deep?: boolean): Elements;
	focus(): this;
	blur(): this;
}
/**
 * Base class for BoneMarrow UI components.
 *
 * Lifecycle:
 * 1. `constructor` → sets up scope, calls `init()`
 * 2. `init()` → override to wire events, create children, bind model
 * 3. `render()` → override to update DOM from model state
 * 4. `destroy()` → disposes scope, which cascades to all children
 *
 * Model lifecycle:
 * View does not automatically destroy the model. Wire it yourself in init()
 * if you want the model to die with the view:
 *   `this.scope.onDispose(() => this.model.destroy())`
 * Or pass the view's scope to the model at construction:
 *   `new Model(data, this.scope)`
 *
 * @example
 * class CardView extends View<CardModel> {
 *   protected init() {
 *     this.$(".title").text(this.model?.get("title") ?? "");
 *     this.on("click", () => this.emit("selected", this.model));
 *   }
 *
 *   protected render() {
 *     this.$(".title").text(this.model?.get("title") ?? "");
 *   }
 * }
 */
export declare class View<T = unknown> {
	protected readonly root: Element;
	protected readonly model?: T | undefined;
	protected readonly scope: Scope;
	private readonly _children;
	constructor(root: Element, model?: T | undefined, options?: ViewOptions);
	/**
	 * Called once during construction after scope is set up.
	 * Override to wire events, create children, bind model.
	 */
	protected init(): void;
	/**
	 * Override to update DOM from current model state.
	 * Not called automatically — invoke manually or wire via onChange:
	 *   `this.model.onChange(() => this.render(), this.scope)`
	 */
	protected render(): void;
	/** Query within the view's root element. */
	protected $(selector: string): Elements;
	/** Wrap the view's root element. */
	protected $root(): Elements;
	/** Focus the view's root element. */
	focus(): this;
	/**
	 * Bind an event listener to the view's root element.
	 * Automatically removed when the view's scope is disposed.
	 */
	protected on(event: string, handler: EventListener): void;
	/**
	 * Bind an event listener to `document`.
	 * Automatically removed when the view's scope is disposed.
	 * Use for global keyboard shortcuts, clicks outside, etc.
	 */
	protected onDocument(event: string, handler: EventListener): void;
	/**
	 * Bind an event listener to `window`.
	 * Automatically removed when the view's scope is disposed.
	 * Use for resize, scroll, hashchange, etc.
	 */
	protected onWindow(event: string, handler: EventListener): void;
	/**
	 * Dispatch a CustomEvent from the view's root element.
	 * Bubbles and is cancelable by default — consistent with native DOM events.
	 */
	protected emit(event: string, detail?: unknown): void;
	/**
	 * Create a child view owned by this view's scope.
	 * The child is destroyed automatically when this view is destroyed.
	 *
	 * @example
	 * const header = this.createChild(HeaderView, this.$(".header").get()!);
	 */
	protected createChild<U, V extends View<U>>(ViewClass: new (root: Element, model?: U, options?: ViewOptions) => V, root: Element, model?: U): V;
	/**
	 * Create child views for each element matching a selector.
	 * An optional modelFn maps each element to a model instance.
	 */
	protected createChildren<U, V extends View<U>>(ViewClass: new (root: Element, model?: U, options?: ViewOptions) => V, selector: string, modelFn?: (element: Element, index: number) => U): V[];
	show(): this;
	hide(): this;
	toggle(force?: boolean): this;
	isVisible(): boolean;
	/**
	 * Destroy this view.
	 * Disposes the view's scope, which cascades to all child views via the
	 * scope tree. No manual child iteration needed.
	 *
	 * Idempotent — safe to call multiple times.
	 */
	destroy(): void;
	/**
	 * True if this view has been destroyed.
	 */
	isDestroyed(): boolean;
	getRoot(): Element;
	getModel(): T | undefined;
	private _setupAutoDestroy;
	private checkDestroyed;
}
/**
 * Create a view from a CSS selector string or Element.
 *
 * @throws If the selector matches no element.
 * @throws If called outside a browser environment.
 *
 * @example
 * const card = createView(CardView, "#card", model);
 */
export declare function createView<T, V extends View<T>>(ViewClass: new (root: Element, model?: T, options?: ViewOptions) => V, root: Element | string, model?: T, options?: ViewOptions): V;
/**
 * Create an Elements wrapper from various input types.
 *
 * Supported inputs:
 * - CSS selector string — queried against `root` (default: document)
 * - Element — wrapped directly
 * - Elements — returned as-is (identity passthrough)
 * - NodeList — non-Element nodes are filtered out silently
 * - HTMLCollection — wrapped directly
 * - Element[] — non-Element items are filtered out with a warning
 *
 * @param root - The node to query against when `input` is a selector string.
 *               Accepts any ParentNode: Document, Element, DocumentFragment,
 *               or ShadowRoot. Defaults to `document`.
 *
 * @example
 * el(".card")                        // query document
 * el(".card", dialog)                // query within a specific element
 * el(someElement)                    // wrap a single element
 * el(someElements)                   // passthrough
 * el(document.querySelectorAll("p")) // wrap a NodeList
 */
export declare function el(input: string | Element | Elements | NodeList | HTMLCollection | Element[], root?: ParentNode): Elements;
/**
 * Create an Elements wrapper by parsing an HTML string.
 *
 * Uses a <template> element for safe, inert parsing — scripts are not
 * executed and the HTML is not inserted into the document.
 *
 * ⚠️ Only element nodes are returned. Top-level text nodes in the HTML
 * string are silently dropped. For example:
 *   elFromHtml('hello <strong>world</strong>')
 * returns only the <strong> element, not the "hello " text node.
 *
 * @example
 * const [card] = elFromHtml('<div class="card"><p>Hello</p></div>');
 */
export declare function elFromHtml(html: string): Elements;
/**
 * Type guard — check if a value is an Elements wrapper.
 *
 * @example
 * if (isElements(input)) { input.addClass("active"); }
 */
export declare function isElements(input: unknown): input is Elements;
/**
 * Create a sequential, non-overlapping refresh loop.
 *
 * The loop waits for each execution to finish before scheduling the next,
 * preventing overlapping requests regardless of how slow fn() is.
 *
 * fn receives a fresh AbortSignal each tick. The signal is aborted if stop()
 * is called while that tick is in flight. Pass it to fetch() or any
 * cancellable async operation.
 *
 * @example
 * const refresh = createRefresh(
 *   async (signal) => {
 *     const res = await fetch("/api/data", { signal });
 *     store.set(await res.json());
 *   },
 *   { interval: 5000, scope }
 * );
 *
 * refresh.pause();
 * refresh.resume();
 * refresh.stop();
 *
 * @throws If interval is not a positive number.
 */
export declare function createRefresh(fn: (signal: AbortSignal) => Promise<unknown>, opts: RefreshOptions): RefreshController;

export {};
