// Generated by dts-bundle-generator v9.5.1

export type DisposeFn = () => void;
export interface Scope {
	readonly signal: AbortSignal;
	onDispose(fn: DisposeFn): void;
	createChild(): Scope;
	dispose(): void;
}
/**
 * Create a new scope attached to the window scope.
 */
export declare function createScope(): Scope;
/**
 * Type-safe event emitter with automatic cleanup and error isolation.
 *
 * @example
 * type Events = {
 *   change: [data: string];
 *   reset: [];
 * };
 *
 * const emitter = new TypedEmitter<Events>();
 * emitter.on("change", (data) => {
 *   console.log(data); // data is string
 * });
 */
export declare class TypedEmitter<TEvents extends Record<string, unknown[]>> {
	private events;
	private debugMode;
	constructor(options?: {
		debug?: boolean;
	});
	/**
	 * Register an event listener.
	 */
	on<K extends keyof TEvents>(event: K, fn: (...args: TEvents[K]) => void, scope?: Scope): DisposeFn;
	/**
	 * Register a one-time event listener.
	 */
	once<K extends keyof TEvents>(event: K, fn: (...args: TEvents[K]) => void, scope?: Scope): DisposeFn;
	/**
	 * Emit an event to all registered listeners.
	 * Errors are isolated per handler.
	 */
	emit<K extends keyof TEvents>(event: K, ...args: TEvents[K]): void;
	/**
	 * Remove all listeners for a specific event.
	 */
	off<K extends keyof TEvents>(event: K): void;
	/**
	 * Remove all listeners for all events.
	 */
	clear(): void;
	hasListeners<K extends keyof TEvents>(event: K): boolean;
	listenerCount<K extends keyof TEvents>(event: K): number;
	eventNames(): Array<keyof TEvents>;
	setDebug(enabled: boolean): void;
}
/**
 * Simple untyped emitter for cases where type safety isn’t needed.
 * Prefer TypedEmitter when possible.
 */
export declare class Emitter {
	private events;
	on(event: string, fn: (...args: any[]) => void, scope?: Scope): DisposeFn;
	once(event: string, fn: (...args: unknown[]) => void, scope?: Scope): DisposeFn;
	emit(event: string, ...args: unknown[]): void;
	off(event: string): void;
	clear(): void;
	hasListeners(event: string): boolean;
	listenerCount(event: string): number;
	eventNames(): string[];
}
export interface FetchOptions<T> {
	scope?: Scope;
	abort?: boolean;
	timeout?: number;
	retryOnFailure?: number;
	retryDelay?: number;
	dedupe?: boolean;
	init?: RequestInit;
	parse?: (json: unknown) => T;
}
export declare function fetchJson<T>(url: string, options?: FetchOptions<T>): Promise<T>;
export declare class Model<T extends object> {
	private data;
	private initial;
	private emitter;
	private destroyed;
	constructor(initial: T);
	get<K extends keyof T>(key: K): T[K];
	getAll(): T;
	set(patch: Partial<T>): boolean;
	reset(): void;
	has<K extends keyof T>(key: K, value: T[K]): boolean;
	onChange(fn: (patch: Partial<T>) => void, scope?: Scope): DisposeFn;
	fetch(url: string, options?: FetchOptions<Partial<T>>): Promise<T>;
	autoRefresh(url: string, options: {
		interval: number;
		scope: Scope;
		immediate?: boolean;
		fetch?: FetchOptions<Partial<T>>;
	}): DisposeFn;
	destroy(): void;
	isDestroyed(): boolean;
	private checkDestroyed;
}
export declare class Collection<T> {
	private items;
	private emitter;
	private destroyed;
	getAll(): T[];
	get length(): number;
	at(index: number): T | undefined;
	add(...items: T[]): void;
	remove(predicate: (item: T, index: number) => boolean): T[];
	removeAt(index: number): T | undefined;
	find(predicate: (item: T, index: number) => boolean): T | undefined;
	findIndex(predicate: (item: T, index: number) => boolean): number;
	filter(predicate: (item: T, index: number) => boolean): T[];
	map<U>(fn: (item: T, index: number) => U): U[];
	forEach(fn: (item: T, index: number) => void): void;
	some(predicate: (item: T, index: number) => boolean): boolean;
	every(predicate: (item: T, index: number) => boolean): boolean;
	sort(compareFn?: (a: T, b: T) => number): void;
	reset(items: T[]): void;
	clear(): void;
	fetch(url: string, options?: FetchOptions<T[]>): Promise<T[]>;
	onAdd(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onRemove(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onReset(fn: (items: T[]) => void, scope?: Scope): DisposeFn;
	onSort(fn: () => void, scope?: Scope): DisposeFn;
	onChange(fn: () => void, scope?: Scope): DisposeFn;
	autoRefresh(url: string, opts: {
		interval: number;
		scope: Scope;
		immediate?: boolean;
		fetch?: FetchOptions<T[]>;
	}): DisposeFn;
	destroy(): void;
	isDestroyed(): boolean;
	private checkDestroyed;
}
export declare class Elements {
	readonly nodes: Element[];
	constructor(nodes: Element[]);
	get length(): number;
	each(fn: (el: Element, index: number) => void): this;
	get(index?: number): Element | null;
	first(): Element | null;
	last(): Element | null;
	find(selector: string): Elements;
	filter(predicate: ((el: Element, index: number) => boolean) | string): Elements;
	parent(): Elements;
	closest(selector: string): Elements;
	children(): Elements;
	text(value?: string): string | this;
	html(value?: string): string | this;
	attr(name: string, value?: string): string | this;
	removeAttr(name: string): this;
	data(key: string, value?: string): string | this;
	val(value?: string): string | this;
	on(event: string, handler: EventListener, scope?: Scope): this;
	once(event: string, handler: EventListener): this;
	off(event: string, handler: EventListener): this;
	trigger(event: string, detail?: any): this;
	addClass(classes: string): this;
	removeClass(classes: string): this;
	toggleClass(classes: string, force?: boolean): this;
	hasClass(className: string): boolean;
	css(property: string | Record<string, string>, value?: string): string | this;
	show(): this;
	hide(): this;
	toggle(show?: boolean): this;
	isVisible(): boolean;
	append(content: Elements | Element | string): this;
	prepend(content: Elements | Element | string): this;
	remove(): this;
	empty(): this;
	clone(deep?: boolean): Elements;
	focus(): this;
	blur(): this;
}
export interface ViewOptions {
	autoDestroy?: boolean;
	parentScope?: Scope;
}
/**
 * Base View class for creating reusable UI components.
 */
export declare class View<T = any> {
	protected readonly root: Element;
	protected readonly model?: T | undefined;
	protected readonly scope: Scope;
	private destroyed;
	private children;
	private options;
	constructor(root: Element, model?: T | undefined, options?: ViewOptions);
	protected init(): void;
	protected $(selector: string): Elements;
	protected $root(): Elements;
	protected createChild<U, V extends View<U>>(ViewClass: new (root: Element, model?: U, options?: ViewOptions) => V, root: Element, model?: U): V;
	protected createChildren<U, V extends View<U>>(ViewClass: new (root: Element, model?: U, options?: ViewOptions) => V, selector: string, modelFn?: (element: Element, index: number) => U): V[];
	protected emit(event: string, detail?: any): void;
	protected on(event: string, handler: EventListener): void;
	show(): void;
	hide(): void;
	toggle(force?: boolean): void;
	isVisible(): boolean;
	isDestroyed(): boolean;
	getRoot(): Element;
	getModel(): T | undefined;
	destroy(): void;
	private setupAutoDestroy;
	private checkDestroyed;
}
/**
 * Convenience function to create a view.
 */
export declare function createView<T, V extends View<T>>(ViewClass: new (root: Element, model?: T, options?: ViewOptions) => V, root: Element | string, model?: T, options?: ViewOptions): V;
/**
 * Create an Elements wrapper from various input types.
 * Similar to jQuery’s $() but returns a lightweight Elements wrapper.
 */
export declare function el(input: string | Element | NodeList | HTMLCollectionOf<Element> | Element[], root?: ParentNode): Elements;
/**
 * Create an Elements wrapper from an HTML string.
 */
export declare function elFromHtml(html: string): Elements;
/**
 * Check if a value is an Elements wrapper.
 */
export declare function isElements(input: unknown): input is Elements;
export interface SequentialRefreshOptions {
	interval: number;
	scope: Scope;
	immediate?: boolean;
	onError?: (error: unknown) => void;
	maxRetries?: number;
	backoff?: boolean;
}
/**
 * Start a sequential auto-refresh loop that prevents overlapping requests.
 */
export declare function startSequentialRefresh(fn: () => Promise<unknown>, opts: SequentialRefreshOptions): DisposeFn;
/**
 * Create a pausable sequential refresh controller.
 */
export declare function createPausableRefresh(fn: () => Promise<unknown>, opts: SequentialRefreshOptions): {
	pause: () => void;
	resume: () => void;
	stop: () => void;
	isPaused: () => boolean;
	isRunning: () => boolean;
};

export {};
